---
title: 'From Nand to Tetris: Learning Software Engineering Fundamentals'
date: 2017-11-29 23:30:00 Z
categories:
- software engineering
tags:
- Learning
- Coursera
- Software engineering
comments: true
---

We all have different paths to how we learned in order to become software engineers. Some of us learn it on their own, watching tutorials online, some reading books, some through experience, some majored in Computer Science in college, and others took some classes or a bootcamp. No matter the approach, a strong grasp of first principles is crucial.

> I think it’s important to reason from first principles rather than by analogy. The normal way we conduct our lives is we reason by analogy. \[With analogy\] we are doing this because it’s like something else that was done, or it is like what other people are doing. \[With first principles\] you boil things down to the most fundamental truths…and then reason up from there.
> -Elon Musk

Not having studies Computer Science myself (I studied Industrial Engineering), I always felt there were some significant mental gaps in my understanding of how modern computers work.  specially at the lower levels. Given that I use computers everyday, this was something I was not only impatient to remedy, but also incredibly curious about. That is why one day when listening to [Ruby Rogues](https://devchat.tv/ruby-rogues),  a wonderful  Ruby Podcast, someone mentioned something that caught my attention. At the end of the podcast each guest gives his pick, or recommendation. One of the guest recommended taking the online course [From NAND to Tetris: Building a Modern Computer From First Principles](http://nand2tetris.org/). He recounted how much it had helped him solidify his foundational knowledge on computation. This was something I had to jump on. 

The course is available on [Coursera ](https://www.coursera.org/learn/build-a-computer)in a very easy to consume format. It starts with teaching you some first principles of computation, and after each section you are tasked with implementing what you learned. The first week for example, you learn about combinatorial logic, and start with only one given, the Nand gate. From that single gate, you can build all other logic gates. That first week you have to implement And, Or, Xor, Dmux, Mux, and their many varying flavors, bus sizes, etc. The following weeks, you go on to implement more complex chips, building on top of the former, for example: an Algorithmic Logic Unit (ALU), Program Counter, and Random Access Memory (RAM) and so on.

I'm currently 3 weeks in and have a newfound appreciation about how these discrete computation machines really work. So much complexity and elegance at the same time. It has been eye opening to see first hand how the concept of abstraction and then symbolism is used all the way from the chip to software. I could not recommend this course more if you want to have a solid foundation as a Software Engineer.
